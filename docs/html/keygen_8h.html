<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Signature Scheme Implementation: signature-scheme/include/keygen.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Signature Scheme Implementation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('keygen_8h.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">keygen.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>It is the header file for the key generation module.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;flint/nmod_mat.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &quot;<a class="el" href="matrix_8h_source.html">matrix.h</a>&quot;</code><br />
</div>
<p><a href="keygen_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a204bf37acc3588b6f477c4a596696196" id="r_a204bf37acc3588b6f477c4a596696196"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a204bf37acc3588b6f477c4a596696196">create_generator_matrix_from_seed</a> (slong n, slong k, slong d, nmod_mat_t gen_matrix, const unsigned char *seed, FILE *output_file)</td></tr>
<tr class="memdesc:a204bf37acc3588b6f477c4a596696196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a generator matrix from seed object.  <br /></td></tr>
<tr class="memitem:a9fd818f1cb7766e64fabb4002731329b" id="r_a9fd818f1cb7766e64fabb4002731329b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9fd818f1cb7766e64fabb4002731329b">generate_parity_check_matrix_from_seed</a> (slong n, slong k, slong d, nmod_mat_t H, const unsigned char *seed, FILE *output_file)</td></tr>
<tr class="memdesc:a9fd818f1cb7766e64fabb4002731329b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates a parity check matrix from a seed.  <br /></td></tr>
<tr class="memitem:a5e0b69ad3033a8fdc973789a0abd4b93" id="r_a5e0b69ad3033a8fdc973789a0abd4b93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e0b69ad3033a8fdc973789a0abd4b93">get_or_generate_matrix_with_seed</a> (const char *prefix, int n, int k, int d, nmod_mat_t matrix, void(*generate_func)(slong, slong, slong, nmod_mat_t, FILE *), void(*generate_from_seed_func)(slong, slong, slong, nmod_mat_t, const unsigned char *, FILE *), FILE *output_file, bool regenerate, bool use_seed_mode, unsigned char *seed_out)</td></tr>
<tr class="memdesc:a5e0b69ad3033a8fdc973789a0abd4b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the or generate matrix with seed object.  <br /></td></tr>
<tr class="memitem:a234de192b3dd4ce89cc8dca7cdf93003" id="r_a234de192b3dd4ce89cc8dca7cdf93003"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a234de192b3dd4ce89cc8dca7cdf93003">generate_keys</a> (struct <a class="el" href="structcode.html">code</a> *C_A, struct <a class="el" href="structcode.html">code</a> *C1, struct <a class="el" href="structcode.html">code</a> *C2, nmod_mat_t <a class="el" href="params_8c.html#abb953f253a118190024fe5adb406bfcf">H_A</a>, nmod_mat_t <a class="el" href="params_8c.html#af7e08370dd89aa3e493f9c9a0381af3a">G1</a>, nmod_mat_t <a class="el" href="params_8c.html#ac48fb7806f2805c3e2ac08237863ee4b">G2</a>, bool use_seed_mode, bool regenerate, FILE *output_file, unsigned char *h_a_seed, unsigned char *g1_seed, unsigned char *g2_seed)</td></tr>
<tr class="memdesc:a234de192b3dd4ce89cc8dca7cdf93003"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is a function that generates keys for a signature scheme based on the provided parameters and options.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>It is the header file for the key generation module. </p>
</div><a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a204bf37acc3588b6f477c4a596696196" name="a204bf37acc3588b6f477c4a596696196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a204bf37acc3588b6f477c4a596696196">&#9670;&#160;</a></span>create_generator_matrix_from_seed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void create_generator_matrix_from_seed </td>
          <td>(</td>
          <td class="paramtype">slong</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slong</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slong</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nmod_mat_t</td>          <td class="paramname"><span class="paramname"><em>gen_matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *</td>          <td class="paramname"><span class="paramname"><em>output_file</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a generator matrix from seed object. </p>
<p>This function generates a generator matrix of size k x n using a deterministic approach based on a provided seed. The seed is used to generate random entries in the matrix, ensuring that the same seed will always produce the same matrix. The entries are generated modulo MOD. The process involves the following steps:</p><ol type="1">
<li><b>Stream Buffer Allocation:</b> A buffer (<span class="tt">stream</span>) is allocated to hold the random bytes needed for the matrix entries. The size of this buffer is determined by the number of entries in the matrix (k * n) multiplied by the size of each entry (4 bytes for a uint32_t).</li>
<li><b>Deterministic Random Generation:</b> The <span class="tt">randombytes_buf_deterministic</span> function from the Sodium library is used to fill the buffer with random bytes based on the provided seed. This ensures that the same seed will always produce the same sequence of random bytes. It's important to note that this function uses the ChaCha20 algorithm under the hood for secure random number generation.</li>
<li><b>Matrix Entry Population:</b> The function iterates over each entry in the generator matrix and fills it with values derived from the buffer. Each entry is constructed by combining 4 bytes from the buffer into a single <span class="tt">uint32_t</span> value, which is then reduced modulo MOD to fit within the required range.</li>
<li><b>Memory Cleanup:</b> The allocated buffer is freed to avoid memory leaks. <dl class="section note"><dt>Note</dt><dd>The function does not return any value; it directly modifies the provided <span class="tt">gen_matrix</span> object. It also requires a seed to ensure deterministic behavior, which is passed as an argument. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>It is the total number of columns in the generator matrix. It represents the length of the codewords generated by the matrix. </td></tr>
    <tr><td class="paramname">k</td><td>It is the number of rows in the generator matrix. It represents the dimension of the code, which is the number of information symbols that can be encoded. </td></tr>
    <tr><td class="paramname">d</td><td>It is the minimum distance of the code. This parameter is not directly used in the function but is typically relevant for the properties of the code being generated. </td></tr>
    <tr><td class="paramname">gen_matrix</td><td>It is a pointer to an <span class="tt">nmod_mat_t</span> type, which represents the generator matrix to be created. The function initializes this matrix with random entries modulo MOD. </td></tr>
    <tr><td class="paramname">seed</td><td>It is a pointer to an unsigned char array that serves as the seed for the deterministic random number generation. The size of this array should be equal to <span class="tt">SEED_SIZE</span>, which is defined in the constants header file. </td></tr>
    <tr><td class="paramname">output_file</td><td>It is a pointer to a <span class="tt">FILE</span> object where any output or debug information can be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void This function does not return any value. It modifies the provided <span class="tt">gen_matrix</span> object directly and fills it with values derived from the seed. </dd></dl>
</li>
</ol>

</div>
</div>
<a id="a234de192b3dd4ce89cc8dca7cdf93003" name="a234de192b3dd4ce89cc8dca7cdf93003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a234de192b3dd4ce89cc8dca7cdf93003">&#9670;&#160;</a></span>generate_keys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void generate_keys </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcode.html">code</a> *</td>          <td class="paramname"><span class="paramname"><em>C_A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcode.html">code</a> *</td>          <td class="paramname"><span class="paramname"><em>C1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcode.html">code</a> *</td>          <td class="paramname"><span class="paramname"><em>C2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nmod_mat_t</td>          <td class="paramname"><span class="paramname"><em>H_A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nmod_mat_t</td>          <td class="paramname"><span class="paramname"><em>G1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nmod_mat_t</td>          <td class="paramname"><span class="paramname"><em>G2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>use_seed_mode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>regenerate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *</td>          <td class="paramname"><span class="paramname"><em>output_file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>h_a_seed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>g1_seed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>g2_seed</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is a function that generates keys for a signature scheme based on the provided parameters and options. </p>
<p>This function generates keys for a signature scheme by creating a parity check matrix (H_A) and two generator matrices (G1 and G2) based on the provided code parameters (C_A, C1, C2). It supports both random generation and seed-based generation of matrices. The generated matrices are saved to files, and if seed-based generation is used, the seeds are also saved. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C_A</td><td>It is a pointer to a <span class="tt">struct code</span> object that contains the parameters for the first code, including its length (n), dimension (k), and minimum distance (d). This code is used to generate the parity check matrix H_A. </td></tr>
    <tr><td class="paramname">C1</td><td>It is a pointer to a <span class="tt">struct code</span> object that contains the parameters for the first generator code, including its length (n), dimension (k), and minimum distance (d). This code is used to generate the first generator matrix G1. </td></tr>
    <tr><td class="paramname">C2</td><td>It is a pointer to a <span class="tt">struct code</span> object that contains the parameters for the second generator code, including its length (n), dimension (k), and minimum distance (d). This code is used to generate the second generator matrix G2. </td></tr>
    <tr><td class="paramname">H_A</td><td>It is a pointer to an <span class="tt">nmod_mat_t</span> type, which represents the parity check matrix H_A to be generated. The function initializes this matrix with random entries or from a seed, depending on the options provided. </td></tr>
    <tr><td class="paramname">G1</td><td>It is a pointer to an <span class="tt">nmod_mat_t</span> type, which represents the first generator matrix G1 to be generated. The function initializes this matrix with random entries or from a seed, depending on the options provided. </td></tr>
    <tr><td class="paramname">G2</td><td>It is a pointer to an <span class="tt">nmod_mat_t</span> type, which represents the second generator matrix G2 to be generated. The function initializes this matrix with random entries or from a seed, depending on the options provided. </td></tr>
    <tr><td class="paramname">use_seed_mode</td><td>It is a boolean flag that indicates whether to use seed-based generation for the matrices. If set to true, the function will generate the matrices using a seed; if false, it will generate the matrices randomly. </td></tr>
    <tr><td class="paramname">regenerate</td><td>It is a boolean flag that indicates whether to regenerate the matrices even if they already exist. If set to true, the function will always generate new matrices; if false, it will load the existing matrices if available. </td></tr>
    <tr><td class="paramname">output_file</td><td>It is a pointer to a <span class="tt">FILE</span> object where any output or debug information can be written. This parameter is optional and can be used for logging purposes, but in this implementation, it is not used. </td></tr>
    <tr><td class="paramname">h_a_seed</td><td>It is a pointer to an unsigned char array where the generated seed for the parity check matrix H_A will be stored if seed-based generation is used. The size of this array should be equal to <span class="tt">SEED_SIZE</span>, which is defined in the constants header file. If seed-based generation is not used, this parameter can be NULL. </td></tr>
    <tr><td class="paramname">g1_seed</td><td>It is a pointer to an unsigned char array where the generated seed for the first generator matrix G1 will be stored if seed-based generation is used. The size of this array should be equal to <span class="tt">SEED_SIZE</span>, which is defined in the constants header file. If seed-based generation is not used, this parameter can be NULL. </td></tr>
    <tr><td class="paramname">g2_seed</td><td>It is a pointer to an unsigned char array where the generated seed for the second generator matrix G2 will be stored if seed-based generation is used. The size of this array should be equal to <span class="tt">SEED_SIZE</span>, which is defined in the constants header file. If seed-based generation is not used, this parameter can be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void This function does not return any value. It directly modifies the provided matrices (H_A, G1, G2) and saves them to files if necessary. If seed-based generation is used, it also saves the generated seeds to files. </dd></dl>

</div>
</div>
<a id="a9fd818f1cb7766e64fabb4002731329b" name="a9fd818f1cb7766e64fabb4002731329b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fd818f1cb7766e64fabb4002731329b">&#9670;&#160;</a></span>generate_parity_check_matrix_from_seed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void generate_parity_check_matrix_from_seed </td>
          <td>(</td>
          <td class="paramtype">slong</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slong</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slong</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nmod_mat_t</td>          <td class="paramname"><span class="paramname"><em>H</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *</td>          <td class="paramname"><span class="paramname"><em>output_file</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function generates a parity check matrix from a seed. </p>
<p>The function initializes a parity check matrix of size (n-k) x n using a deterministic approach based on a provided seed. The seed is used to generate random entries in the matrix, ensuring that the same seed will always produce the same matrix. The entries are generated modulo MOD. The process involves the following steps:</p><ol type="1">
<li><b>Stream Buffer Allocation:</b> A buffer (<span class="tt">stream</span>) is allocated to hold the random bytes needed for the matrix entries. The size of this buffer is determined by the number of entries in the matrix ((n-k) * n) multiplied by the size of each entry (4 bytes for a uint32_t).</li>
<li><b>Deterministic Random Generation:</b> The <span class="tt">randombytes_buf_deterministic</span> function from the Sodium library is used to fill the buffer with random bytes based on the provided seed. This ensures that the same seed will always produce the same sequence of random bytes. It's important to note that this function uses the ChaCha20 algorithm under the hood for secure random number generation.</li>
</ol>
<p>3. <b>Matrix Entry Population:</b> The function iterates over each entry in the parity check matrix and fills it with values derived from the buffer. Each entry is constructed by combining 4 bytes from the buffer into a single <span class="tt">uint32_t</span> value, which is then reduced modulo MOD to fit within the required range.</p><ol type="1">
<li><b>Memory Cleanup:</b> The allocated buffer is freed to avoid memory leaks. <dl class="section note"><dt>Note</dt><dd>The function does not return any value; it directly modifies the provided <span class="tt">H</span> object. It also requires a seed to ensure deterministic behavior, which is passed as an argument. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>It is the total number of columns in the parity check matrix. It represents the length of the codewords that the matrix checks for validity. </td></tr>
    <tr><td class="paramname">k</td><td>It is the number of rows in the parity check matrix. It represents the dimension of the code, which is the number of information symbols that can be encoded. </td></tr>
    <tr><td class="paramname">d</td><td>It is the minimum distance of the code. This parameter is not directly used in the function but is typically relevant for the properties of the code being generated. </td></tr>
    <tr><td class="paramname">H</td><td>It is a pointer to an <span class="tt">nmod_mat_t</span> type, which represents the parity check matrix to be created. The function initializes this matrix with random entries modulo MOD. </td></tr>
    <tr><td class="paramname">seed</td><td>It is a pointer to an unsigned char array that serves as the seed for the deterministic random number generation. The size of this array should be equal to <span class="tt">SEED_SIZE</span>, which is defined in the constants header file. </td></tr>
    <tr><td class="paramname">output_file</td><td>It is a pointer to a <span class="tt">FILE</span> object where any output or debug information can be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void This function does not return any value. It modifies the provided <span class="tt">H</span> object directly and fills it with values derived from the seed. </dd></dl>
</li>
</ol>

</div>
</div>
<a id="a5e0b69ad3033a8fdc973789a0abd4b93" name="a5e0b69ad3033a8fdc973789a0abd4b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e0b69ad3033a8fdc973789a0abd4b93">&#9670;&#160;</a></span>get_or_generate_matrix_with_seed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void get_or_generate_matrix_with_seed </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nmod_mat_t</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*</td>          <td class="paramname"><span class="paramname"><em>generate_func&#160;</em></span>)(slong, slong, slong, nmod_mat_t, FILE *), </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*</td>          <td class="paramname"><span class="paramname"><em>generate_from_seed_func&#160;</em></span>)(slong, slong, slong, nmod_mat_t, const unsigned char *, FILE *), </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *</td>          <td class="paramname"><span class="paramname"><em>output_file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>regenerate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>use_seed_mode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>seed_out</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the or generate matrix with seed object. </p>
<p>This function checks if a matrix file exists for the given parameters (prefix, n, k, d). If it does and regeneration is not requested, it loads the matrix from the file. If the file does not exist or regeneration is requested, it generates a new matrix either using a random generation function or a seed-based generation function. The generated matrix is then saved to a file. This function is designed to handle both random and seed-based generation of matrices, allowing for reproducibility when using the same seed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>It is a string that serves as a prefix for the filename of the matrix. This prefix is used to create a unique filename based on the parameters n, k, and d. </td></tr>
    <tr><td class="paramname">n</td><td>It is the total number of columns in the matrix. It represents the length of the codewords generated by the matrix. </td></tr>
    <tr><td class="paramname">k</td><td>It is the number of rows in the matrix. It represents the dimension of the code, which is the number of information symbols that can be encoded. </td></tr>
    <tr><td class="paramname">d</td><td>It is the minimum distance of the code. This parameter is not directly used in the function but is typically relevant for the properties of the code being generated. </td></tr>
    <tr><td class="paramname">matrix</td><td>It is a pointer to an <span class="tt">nmod_mat_t</span> type, which represents the matrix to be generated or loaded. The function initializes this matrix with random entries or loads it from a file if it already exists. </td></tr>
    <tr><td class="paramname">generate_func</td><td>It is a pointer to a function that generates a matrix with random entries. This function should take parameters (n, k, d, matrix, output_file) and fill the matrix with random values. </td></tr>
    <tr><td class="paramname">generate_from_seed_func</td><td>It is a pointer to a function that generates a matrix from a seed. This function should take parameters (n, k, d, matrix, seed, output_file) and fill the matrix with values derived from the seed. </td></tr>
    <tr><td class="paramname">output_file</td><td>It is a pointer to a <span class="tt">FILE</span> object where any output or debug information can be written. This parameter is optional and can be used for logging purposes, but in this implementation, it is not used. </td></tr>
    <tr><td class="paramname">regenerate</td><td>It is a boolean flag that indicates whether to regenerate the matrix even if it already exists. If set to true, the function will always generate a new matrix; if false, it will load the existing matrix if available. </td></tr>
    <tr><td class="paramname">use_seed_mode</td><td>It is the boolean flag that indicates whether to use seed-based generation for the matrix. If set to true, the function will generate the matrix using a seed; if false, it will generate the matrix randomly.</td></tr>
    <tr><td class="paramname">seed_out</td><td>It is a pointer to an unsigned char array where the generated seed will be stored if seed-based generation is used. The size of this array should be equal to <span class="tt">SEED_SIZE</span>, which is defined in the constants header file. If seed-based generation is not used, this parameter can be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void This function does not return any value. It modifies the provided matrix object directly and saves it to a file if necessary. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="dir_2f80228ae10e8992c0359fcc0b448edb.html">signature-scheme</a></li><li class="navelem"><a href="dir_db9c7b5bda17bb91c755428bded24c4d.html">include</a></li><li class="navelem"><a href="keygen_8h.html">keygen.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
